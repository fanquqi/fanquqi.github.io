<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="fanquqi.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="fanquqi.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="fanquqi.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="fanquqi.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="fanquqi.github.io/css/main.css">


<link rel="stylesheet" href="fanquqi.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fanquqi.github.io","root":"fanquqi.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Raise my flag to the new age.">
<meta property="og:type" content="website">
<meta property="og:title" content="fix u dream">
<meta property="og:url" content="https://fanquqi.github.io/page/3/index.html">
<meta property="og:site_name" content="fix u dream">
<meta property="og:description" content="Raise my flag to the new age.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fanquqi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fanquqi.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>fix u dream</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="fanquqi.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fix u dream</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="fanquqi.github.io/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="fanquqi.github.io/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/11/27/curl%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/11/27/curl%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">curl使用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-27 14:18:06" itemprop="dateCreated datePublished" datetime="2017-11-27T14:18:06+08:00">2017-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:03" itemprop="dateModified" datetime="2020-05-21T20:56:03+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="fanquqi.github.io/categories/%E5%9F%BA%E7%A1%80%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">基础运维</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>curl是一个命令行工具，用于发出网络请求，提取数据，支持多种协议，用于web开发运维，日常调试。</p>
</blockquote>
<p>参数介绍：</p>
<ul>
<li><code>-o</code> 保存到文件</li>
<li><code>-L</code> 自动跳转</li>
<li><code>-i</code> 显示头信息连同代码一起</li>
<li><code>-I</code> 只显示头信息</li>
<li><code>-v</code> 显示详细的通讯过程</li>
<li><code>-trace file_name</code> 显示更详细的信息到文件中 </li>
<li><code>-X</code> HTTP 方法 POST 或者 GET 默认是GET</li>
<li><code>-x</code> 设置代理 <code>curl -x proxysever.test.com:3128 http://google.co.in</code></li>
<li><code>--referer</code> 模拟提供referer </li>
<li><code>--user-agent</code> 模拟指定设备</li>
<li><code>--header</code> 增肌头信息 比如 Content-Type</li>
<li><code>-u</code> <code>--user</code> 提供HTTP认证，比如有的接口需要用户名密码认证，<code>curl --user name:password example.com</code></li>
</ul>
<p>下边简单记录一些常见的用法实例…</p>
<h3 id="绑定host"><a href="#绑定host" class="headerlink" title="绑定host"></a>绑定host</h3><p>curl 看</p>
<pre><code>curl -H &quot;Host: www.zggo.com&quot; &quot;192.168.0.1/xxx/xxx/db.error.log&quot; </code></pre><h3 id="查看网页源码"><a href="#查看网页源码" class="headerlink" title="查看网页源码"></a>查看网页源码</h3><pre><code>curl www.baidu.com
使用 `-o`命令 下载代码到文件
curl -o /var/tmp/baidu.txt www.baidu.com</code></pre><h3 id="提交表单，传递数据"><a href="#提交表单，传递数据" class="headerlink" title="提交表单，传递数据"></a>提交表单，传递数据</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>直接在url之后添加即可<br>    curl -u username <a href="https://api.github.com/user?access_token=XXXXXXXXXX">https://api.github.com/user?access_token=XXXXXXXXXX</a></p>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>可以用<code>--data-urlencode</code>给参数进行编码</p>
<pre><code>curl -X POST -u username --data &quot;param1=value1&amp;param2=value&quot; https://api.github.com</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/11/14/kafka%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/11/14/kafka%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/" class="post-title-link" itemprop="url">kafka技术细节</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-14 15:57:06" itemprop="dateCreated datePublished" datetime="2017-11-14T15:57:06+08:00">2017-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:03" itemprop="dateModified" datetime="2020-05-21T20:56:03+08:00">2020-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>目前为了解耦每个系统组件，消息异步或者缓冲经常要用到消息队列，当下时兴的消息队列也不在少数。但是提到高吞吐的消息队列，很多人可能会想到kafka，而且目前使用者也是很多，当然作为一个运维人员我们也很想知道，相比于别的MQ它到底优势在哪儿。</p>
</blockquote>
<h1 id="关键词解读"><a href="#关键词解读" class="headerlink" title="关键词解读"></a>关键词解读</h1><ul>
<li><code>Topic</code> 划分messages的逻辑概念，生产和消费需要都需要指定topic</li>
<li><code>replication</code> 副本数，Topic的属性，指存储多少份数据，用来提高容错率</li>
<li><code>patition</code> 分区数，是kafka横向扩展与并行化的基础。每个topic需要指定它的partition数量，最下为1，每个Topic副本会拆分成多个partition，均匀存放到每个broker上，一般为broker的整倍数，消费者的数量也最好与之对应。</li>
<li><code>broker</code> 集群节点，用来接收生产消费请求，并将message并持久化到本地磁盘，每个Cluster当中会选举出一个Broker来担任Controller，负责处理Partition的Leader选举，协调Partition迁移等工作。</li>
</ul>
<h1 id="kafka性能保证（关键技术）"><a href="#kafka性能保证（关键技术）" class="headerlink" title="kafka性能保证（关键技术）"></a>kafka性能保证（关键技术）</h1><h3 id="基于文件系统的顺序磁盘读写"><a href="#基于文件系统的顺序磁盘读写" class="headerlink" title="基于文件系统的顺序磁盘读写"></a>基于文件系统的顺序磁盘读写</h3><p>我之前一直主观上认为磁盘读写很慢，跟内存读写不是一个级别，日常写码也是，要求快速被读到的值一直是放到内存中。很多中间件比如Redis，rabbitmq，也是内存大户，大量的占用内存来保证读写速度。而kafka却不是。。<br>首先，科普下，其实磁盘读写速度非常快也非常慢。怎么讲？<br>这取决于你怎么用它，SATA机械磁盘正常顺序读写速度可以达到600M/s,而随机读写速度仅100K/s.相差近6000倍，所以效率由自己决定。<br>所以，为了保证线性读写，Kafka重度依赖底层操作系统提供的<code>PageCache</code>功能。当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。这样如果Kafka重启，OS管理的PageCache依然可以继续使用。<br>使用PageCache功能同时可以避免在JVM内部缓存数据,减少Full GC，不至于OOM.</p>
<p><strong>相关优化方案</strong></p>
<ol>
<li>Kafka官方并不建议通过Broker端的log.flush.interval.messages和log.flush.interval.ms来强制写盘，认为数据的可靠性应该通过Replica来保证，而强制Flush数据到磁盘会对整体性能产生影响。</li>
<li>可以通过调整/proc/sys/vm/dirty_background_ratio和/proc/sys/vm/dirty_ratio来调优性能。<br>a. 脏页率超过第一个指标会启动pdflush开始Flush Dirty PageCache。<br>b. 脏页率超过第二个指标会阻塞所有的写操作来进行Flush。<br>c. 根据不同的业务需求可以适当的降低dirty_background_ratio和提高dirty_ratio。（vm.dirty_ratio = 20）</li>
</ol>
<h3 id="Java-NIO网络模型"><a href="#Java-NIO网络模型" class="headerlink" title="Java NIO网络模型"></a>Java NIO网络模型</h3><p>在我们接触高性能服务器<code>nginx</code>的时候应该听说过<code>epoll</code><br>所谓<code>IO模型</code>，流传的有四种比较常用的</p>
<ul>
<li>阻塞IO： read/write的时候，阻塞调用</li>
<li>非阻塞IO： read/write，没有数据，立马返回，轮询</li>
<li>IO多路复用：read/write一次都只能监听一个socket，但对于服务器来讲，有成千上完个socket连接，如何用一个函数，可以监听所有的socket上面的读写事件呢？这就是IO复用模型，对应linux上面，就是select/poll/epoll 3种技术。</li>
<li>异步IO：linux上没有，windows上对应的是IOCP</li>
</ul>
<p>在Linux平台上，Java NIO就是基于epoll来实现的。所有基于epoll的框架，都有3个阶段：<br>注册事件(connect,accept,read,write)， 轮询IO是否就绪，执行实际IO操作。</p>
<h3 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h3><p>在kafka consumer消费的过程中，kafka集群用到了zero copy，很大程度上节约了系统资源，减少了io。</p>
<p>正常一次数据从文件中读取到发送流程如下：</p>
<ul>
<li>操作系统把数据从文件拷贝内核中的页缓存中</li>
<li>应用程序从页缓存从把数据拷贝自己的内存缓存中</li>
<li>应用程序将数据写入到内核中 socket 缓存中</li>
<li>操作系统把数据从 socket 缓存中拷贝到网卡接口缓存，从这里发送到网络上。</li>
</ul>
<p>这里面涉及到四次内存调用，两次系统调用,只是一次消息消费需要这么复杂的过程，然而，linux系统中<code>sendfile</code>函数，就是提供了高性能的将数据从页面缓存发送到 socket的功能的函数。这样四步只需要两步就好了。</p>
<h3 id="数据集，端到端批量压缩"><a href="#数据集，端到端批量压缩" class="headerlink" title="数据集，端到端批量压缩"></a>数据集，端到端批量压缩</h3><p>kafka并不是以一个message为单位进行的网络传输，而是把messages 组成一个集合，这个set的大小可以由我们来自主设定。结合服务器的性能来提高工作效率。<br>在某些情况下，瓶颈实际上不是CPU或磁盘，而是网络带宽。 对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。 当然，用户可以一次压缩其消息，而无需Kafka所需的任何支持，但这可能导致非常差的压缩比，因为冗余的很多是由于相同类型的消息之间的重复（例如， Web日志中的JSON或用户代理或通用字符串值）。 有效的压缩需要压缩多个消息，而不是单独压缩每个消息。</p>
<p>Kafka通过递归消息集来支持这一点。 一批消息可以一起压缩并以此形式发送到服务器。 这批消息将以压缩形式写入，并将在日志中保持压缩，并且只能由消费者解压缩。<br>Kafka支持GZIP和Snappy压缩协议，更多的细节可以看这里：<a href="https://cwiki.apache.org/confluence/display/KAFKA/Compression">https://cwiki.apache.org/confluence/display/KAFKA/Compression</a></p>
<p>相关优化方案：<br>增加 <code>messages set</code>size  </p>
<h1 id="生产者特点"><a href="#生产者特点" class="headerlink" title="生产者特点"></a>生产者特点</h1><ul>
<li>批处理，异步发送。kafka生产者使用批处理试图在内存中积累数据，在单个请求发送累积的大批量数据，可以配置批处理积累的不大于一定的消息数，并等待时间不超过配置的延迟（64k 或 10毫秒）。这将累积更多消息 用于少数较大的I/O操作上，为了更好的吞吐量，这种缓存是可配置，并给出一种来权衡极少量的额外的延迟的机制。</li>
<li>负载均衡。生产者将数据直接发送到分区leader的broker上（没有任何干预的路由层）。为了帮助producer做到这一点，Kafka所有节点都可应答给producer哪些服务器是正常的，哪些topic分区的leader允许producer在给定的时间内可以直接请求</li>
<li>控制ack状态。kafka生产者可以跟踪消息状态，提供三种条件选择。0，1，all(-1)。<code>0</code>不保证写入副本;<code>1</code>保证有一个副本确认写入;<code>-1</code>保证所有副本写入成功，才会返回。</li>
</ul>
<h1 id="消费者特点"><a href="#消费者特点" class="headerlink" title="消费者特点"></a>消费者特点</h1><ul>
<li>group分组，每个consumer对应一个patition,</li>
<li>pull模式，更加灵活</li>
<li>通过offset获取进度,更加容易获取，代价更小。</li>
</ul>
<h1 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h1><h1 id="副本和leader选举机制"><a href="#副本和leader选举机制" class="headerlink" title="副本和leader选举机制"></a>副本和leader选举机制</h1><p>为了提高容错率，kafka后期的版本也提供副本规则。以Topic的partition为单位。但是kafka的副本规则和其他的中间件还有点不太一样。<br>正常情况下每个partition副本有一个leader和0-n个follower，所有的读写都在leader上，leader均匀分布在每个broker上，而follower是主动找leader同步数据的。<br>follower的日志完全等同于leader的日志 — 相同的顺序相同的偏移量和消息（当然，在任何一个时间点上，leader比follower多几条消息，尚未同步到follower）</p>
<p>怎么判断副本状态？？？</p>
<ol>
<li>一个节点必须能维持与zookeeper的会话（通过zookeeper的心跳机制）</li>
<li>如果它是一个slave，它必须复制leader并且不能落后”太多”</li>
</ol>
<p>leader跟踪“同步”节点。如果一个follower死掉，卡住，或落后，leader将从同步副本列表中移除它。落后是通过replica.lag.max.messages配置控制，卡住是通过replica.lag.time.max.ms配置控制的。如果达到阈值都会被踢出ISR。</p>
<p><strong>选举机制</strong></p>
<p>普通的选举机制比如zookeeper使用的zab都是投票式选举，这种情况下，如果一共2n+1个节点，必须保证n+1各节点健康，才会投票选举成功。<br>但是这个机制很明显是不合适的对于kafka来说。<br>因为副本数大对于集群来说是很奢侈的，因为多一个副本就是数据量的翻倍，代价有点大。<br>所以kafka提供一个ISR（in-sync replicas，一组同步leader数据的副本）用来记录可以被选举的副本。kafka副本写入不被认为是已提交，直到所有的同步副本已经接收才认为。这组ISR保存在zookeeper，正因为如此，在ISR中的任何副本都有资格当选leader，所以这样集群中有n+1个副本，理论上这个模型允许挂掉n个，而集群不受影响。<br>但是。。这会遇到另一种情况。。<br>比如，我们只有两个副本，而这唯一一个follower是又正好不在ISR中，怎么办 是不是没有作用了？？</p>
<p>不是的。。</p>
<p>这个时候kafka会做一个关于<code>一致性</code>和<code>可用性</code>的权衡，（然而这个权衡你可以通过配置文件来控制）牺牲其中一种来保障另一种。默认是优先保证可用性，也就是说会选举一个可能数据不完全的副本作为leader，然后以它为元数据。这就是<code>unclean l®eader选举</code>可用通过jmx获取这个metrics,作为集群健康的一项指标。</p>
<p>如果我们业务有要求或者你是个完美主义者，当遇到这种情况的时候宁愿不选举出leader，也要保证数据完整性，可用通过<code>unclean.leader.election.enable</code>这个配置来禁用<code>unclean leader 选举</code>。<br>需要注意，kafka的这些选举是由controler来控制的。而controler是在集群中broker中选举出来的，每个集群中同一时间节点只能有一个，如果多个说明集群不正常，这个也有相应的metrics在jmx中获取。作为集群健康的一项指标。如果controler出现故障也会从其他broker中选举。</p>
<h1 id="问题答疑"><a href="#问题答疑" class="headerlink" title="问题答疑"></a>问题答疑</h1><h2 id="删除group"><a href="#删除group" class="headerlink" title="删除group"></a>删除group</h2><p>如何删除group信息</p>
<p>首先明确一点，Kafka是会删除consumer group信息的，既包括位移信息，也包括组元数据信息。对于位移信息而言，前面提到过每条位移消息都设置了过期时间。每个Kafka broker在后台会启动一个线程，定期(由offsets.retention.check.interval.ms确定，默认10分钟)扫描过期位移，并删除之。而对组元数据而言，删除它们的条件有两个：1. 这个group下不能存在active成员，即所有成员都已经退出了group；2. 这个group的所有位移信息都已经被删除了。当满足了这两个条件后，Kafka后台线程会删除group运输局信息。</p>
<p>好了， 我们总说删除，那么Kafka到底是怎么删除的呢——正是通过写入具有相同key的tombstone消息。我们举个例子，假设<strong>consumer_offsets当前保存有一条位移消息，key是【testGroupid，test, 0】（三元组），value是待提交的位移信息。无论何时，只要我们向</strong>consumer_offsets相同分区写入一条key=【testGroupid，test, 0】，value=null的消息，那么Kafka就会认为之前的那条位移信息是可以删除的了——即相当于我们向__consumer_offsets中插入了一个delete mark。</p>
<p>再次强调一下，向__consumer_offsets写入tombstone消息仅仅是标记它之前的具有相同key的消息是可以被删除的，但删除操作通常不会立即开始。真正的删除操作是由log cleaner的Cleaner线程来执行的。</p>
<p>offset过期参数<br>offset.retentions.minuntes  default 10800</p>
<h2 id="kafka-节点-磁盘io高问题排查"><a href="#kafka-节点-磁盘io高问题排查" class="headerlink" title="kafka 节点 磁盘io高问题排查"></a>kafka 节点 磁盘io高问题排查</h2><ol>
<li>看实际流量是不是很大</li>
<li>如果有raid，查看raid缓存策略<br> 如果缓存策略有问题 iotop  看到 系统 [flush] 进程占用io应该是非常高的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># megacli -cfgdsply -aALL|grep Polic  （查看缓存策略）</span><br><span class="line"># megacli -LDSetProp -CachedBadBBU -Lall -aAl （更改电池充放电时刻缓存策略）</span><br></pre></td></tr></table></figure></li>
<li>查看系统内核脏页参数（见上文）</li>
</ol>
<p>参考：<br><a href="http://blog.csdn.net/bigtree_3721/article/details/78411652">http://blog.csdn.net/bigtree_3721/article/details/78411652</a><br><a href="http://www.jasongj.com/tags/Kafka/">http://www.jasongj.com/tags/Kafka/</a><br><a href="http://orchome.com/10">http://orchome.com/10</a><br><a href="http://zqhxuyuan.github.io/2016/01/19/2016-01-19-Kafka-Consumer-scala/">http://zqhxuyuan.github.io/2016/01/19/2016-01-19-Kafka-Consumer-scala/</a></p>
<pre><code></code></pre><p>10.115.106.241</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/11/08/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/11/08/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/" class="post-title-link" itemprop="url">ssh端口转发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-08 16:20:56" itemprop="dateCreated datePublished" datetime="2017-11-08T16:20:56+08:00">2017-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:04" itemprop="dateModified" datetime="2020-05-21T20:56:04+08:00">2020-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>下午闲了一会儿，想起前年实习搬服务器的时候，当时公司的服务器，被我们安装到某个地方的内网之后，没有外网IP只是通过NAT访问外网，但是公司服务器可以直接主动登陆上去操作，当时我还以为是端口转发，或者VPN，两个月之后运维主管离职，从某团空降来一个运维领导，试了一下iptables的端口转发。。。然后采用了VPN，无疑我感觉这很low逼。所以这项神秘的技术一直被我记到现在。。</p>
</blockquote>
<p><strong>下边先介绍下ssh的端口转发</strong></p>
<blockquote>
<p>SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。总的来说 SSH 端口转发能够提供两大功能：</p>
</blockquote>
<ul>
<li><p>加密 SSH Client 端至 SSH Server 端之间的通讯数据。</p>
</li>
<li><p>突破防火墙的限制完成一些之前无法建立的 TCP 连接。</p>
</li>
</ul>
<h1 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h1><p>格式 <code>ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</code></p>
<p>例如 我们将本地8000端口转发到提供<code>LDAP</code>服务的主机Ldapserver_host1 的389端口（ldap_server默认端口）可以这样写</p>
<pre><code>ssh -L 7001:localhost:389 LdapServer_host1</code></pre><p>这个时候<code>netstat -tpln</code> 看</p>
<pre><code>tcp        0      0 127.0.0.1:7001              0.0.0.0:*                   LISTEN           15889/ldap</code></pre><p>本地端口已经起来了 ，但是只允许在本机访问，这个时候区别的机器用 <code>nmap</code>扫描是看不到<code>7001</code>端口的</p>
<p>但是怎么让别的主机也可以使用呢？</p>
<p>SH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。</p>
<pre><code>ssh -g -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; </code></pre><p>这个时候可以使用ssh 提供的<code>Gateway Port</code>关键字<code>-g</code></p>
<pre><code>ssh -g -L 8001:0.0.0.0:22 localhost</code></pre><p><strong>我们把这台主机的22端口转发到本机的8001端口</strong></p>
<p>然后这时候我们可以到另一台机器上 <code>nmap</code>发现本机 8001端口已经打开了  然后试下 ssh -p 8001 是可以登得上的。</p>
<h1 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h1><p>其实这就是所谓的<code>ssh反向隧道</code></p>
<p>主机介绍：</p>
<table>
<thead>
<tr>
<th align="center">主机名</th>
<th>是否有外网地址</th>
<th>地址</th>
<th>用户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">server1</td>
<td>是</td>
<td>123.21.201.189</td>
<td>fanquqi</td>
</tr>
<tr>
<td align="center">server2</td>
<td>否</td>
<td>localhost</td>
<td>fanquqi</td>
</tr>
<tr>
<td align="center">server3</td>
<td>否</td>
<td>localhost</td>
<td>fanquqi</td>
</tr>
</tbody></table>
<p>主要参数</p>
<ul>
<li><code>-R</code>  反向代理</li>
<li><code>-N</code>  不执行远程指令</li>
<li><code>-f</code>  后台执行</li>
</ul>
<p>命令格式</p>
<pre><code>ssh -NfR 6789:localhost:22 fanquqi@123.21.201.189</code></pre><p>在server2上执行上述命令，执行完输完密码之后，我们可以在server1上看下端口  正常6789端口已经是监听了的。</p>
<p>然后 我们可以在 这台外网地址机器上执行 </p>
<pre><code>ssh -p 6789 fanquqi@localhost</code></pre><p>即可连接到连接到NAT后面的server2。。</p>
<p>可以看到上面列出了三台机器，第三台还没有用到。我们来用一下，试下让两台没有外网的机器建立连接。</p>
<p>先杀掉<code>server1</code>上6789端口。<br>在<code>server3</code>上执行</p>
<pre><code>ssh -fN -R 123.21.201.189:6789:localhost:22 fanquqi@123.21.201.189</code></pre><p>然后在<code>server1</code>上确认6789打开</p>
<p>这时候在server2上就可以连接server3了<br>只需要运行</p>
<pre><code>ssh -p 6789 fanquqi@123.21.201.189</code></pre><p>即可。其实不止server1,是任何有网络的机器    </p>
<p>其实我们还可以把公钥互相传一下  就不用来回输密码了。 如果nat后面那台主机不在手边，经常上不去  建议使用<code>autossh</code>提供隧道断开自动重连功能。或者更改ssh配置文件<code>~/.ssh/config</code> </p>
<pre><code>ServerAliveInterval 
ServerAliveCountMax </code></pre><p>更改如上两个参数</p>
<p>第一个参数表示如果服务器（外网）没数据发来则过一段时间客户端（内网）会发送一个空包到服务器，以保持tcp长连接，默认值为0，表示不会发心跳包，这里可以设置一分钟。。<br>第二个参数表示，如果服务器（内网）没有收到心跳包指定次数，就中断连接。可以设置为无限大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/10/25/python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-PP%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/10/25/python%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-PP%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">python并行计算-PP模块使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-25 16:52:11" itemprop="dateCreated datePublished" datetime="2017-10-25T16:52:11+08:00">2017-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:04" itemprop="dateModified" datetime="2020-05-21T20:56:04+08:00">2020-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/10/17/MongoDB%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/10/17/MongoDB%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">MongoDB使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-17 19:11:00" itemprop="dateCreated datePublished" datetime="2017-10-17T19:11:00+08:00">2017-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:03" itemprop="dateModified" datetime="2020-05-21T20:56:03+08:00">2020-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用之前先大概了解下，熟悉下特点与使用场景<br>下边是熟悉过程之中几篇比较好的文章。</p>
<p>MongoDB<a href="http://www.searchdatabase.com.cn/showcontent_51990.htm">内存使用介绍</a></p>
<p>选择了之前的influxdb 这篇文章可能要延期再写了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/10/12/sed%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/10/12/sed%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">sed使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-12 11:50:09" itemprop="dateCreated datePublished" datetime="2017-10-12T11:50:09+08:00">2017-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:04" itemprop="dateModified" datetime="2020-05-21T20:56:04+08:00">2020-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="删除文件行"><a href="#删除文件行" class="headerlink" title="删除文件行"></a>删除文件行</h1><p>删除 <code>1-n</code> 行<br>    &gt; sed -i ‘1,nd’ filename<br>其中<code>-i</code>参数为insert，加上之后就直接改变文件内容，</p>
<h1 id="查找文件内容，并输出匹配行"><a href="#查找文件内容，并输出匹配行" class="headerlink" title="查找文件内容，并输出匹配行"></a>查找文件内容，并输出匹配行</h1><pre><code>&gt; sed -n -e &apos;/host/=&apos; test.json
5
110
215</code></pre><h1 id="在某行下添加一行内容"><a href="#在某行下添加一行内容" class="headerlink" title="在某行下添加一行内容"></a>在某行下添加一行内容</h1><p>此行内容”host,”,</p>
<pre><code>sed &apos;s/host,/&amp;\n&quot;numQueryThreads&quot;: 2,/g&apos; test.json
`&amp;` 表示上文`host,`匹配到的内容，`g`表示全文匹配 不然只匹配第一个匹配项。</code></pre><p>其实也可以用<code>a</code>命令（append）来添加<br>    sed ‘/host/a “numQueryThreads”: 2,’ test.json</p>
<h1 id="行尾追加"><a href="#行尾追加" class="headerlink" title="行尾追加"></a>行尾追加</h1><p>在有<code>test</code>的行后边追加<code>000</code><br>    sed -i ‘/test/ s/$/000/</p>
<h1 id="注释文件"><a href="#注释文件" class="headerlink" title="注释文件"></a>注释文件</h1><p>一般shell,python注释文件就是第一行加#</p>
<pre><code>我们可以vim 打开文件后，输入&quot;:set number&quot; 显示行号，然后比如注释20-25行
:20,25s/^/#/
也可以
sed &apos;/dog/,+3s/^/# /g&apos; pets.txt
其中的+3表示后面连续3行</code></pre><h1 id="替换文件内容"><a href="#替换文件内容" class="headerlink" title="替换文件内容"></a>替换文件内容</h1><pre><code>只替换每一行的第一个s：

$ sed &apos;s/s/S/1&apos; my.txt
ThiS is my cat, my cat&apos;s name is betty

只替换每一行的第二个s：

$ sed &apos;s/s/S/2&apos; my.txt
This iS my cat, my cat&apos;s name is betty</code></pre><h1 id="倒序输出文件"><a href="#倒序输出文件" class="headerlink" title="倒序输出文件"></a>倒序输出文件</h1><pre><code>sed &apos;1!G;h;$!d&apos; filename</code></pre><p>参考：<br><a href="https://coolshell.cn/articles/9104.html">https://coolshell.cn/articles/9104.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/10/08/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/10/08/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">python字符串格式化问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-08 16:20:56" itemprop="dateCreated datePublished" datetime="2017-10-08T16:20:56+08:00">2017-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:04" itemprop="dateModified" datetime="2020-05-21T20:56:04+08:00">2020-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p><img src="http://or2jd66dq.bkt.clouddn.com/unicode_print_error.png" alt=""></p>
<p>我格式化输出一个值竟然报出这种神奇的错误，很不解。</p>
<p>仔细看了下 <code>douban.critic[i]</code>这个变量type是个Unicode。</p>
<p>而前面<code>影评</code>两个字是str不是Unicode 两个值在一起输出就会报错。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Python在格式化字符串的时候有一些隐藏着的小动作：如果%s对应的参数里有unicode，那么最终的结果也是unicode。在这种情况下模版字符串以及所有的%s参数中的str都会被decode成unicode，然而这个decode是隐式的，用户无法指定其使用的charset，Python只能用默认的ASCII。如果正好里面有非ASCII编码的字符串，就完蛋了……</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>统一格式</p>
<p>参考：<br>print u”影评：%s” % douban.critic[i]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/09/26/kafka%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/09/26/kafka%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">kafka流量监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-26 16:17:35" itemprop="dateCreated datePublished" datetime="2017-09-26T16:17:35+08:00">2017-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:03" itemprop="dateModified" datetime="2020-05-21T20:56:03+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="fanquqi.github.io/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>kafka集群越来越多，每次问题出来了很挠头，并不能第一时间定位到问题，也没有多少有效数据，所以对整个集群状态做个有效的记录是十分必要的。<br>所以选择用<code>jmxtrans</code>+<code>influxdb</code>+<code>grafana</code>这三个开源组件做个监控。jmxtrans通过JMX(Java Management Extensions)收集每个kafka实例监控数据，把数据导入到influxDB，然后再grafana集中展示，展示的时候可以按照broker或者集群。</p>
</blockquote>
<h1 id="influxdb安装"><a href="#influxdb安装" class="headerlink" title="influxdb安装"></a>influxdb安装</h1><blockquote>
<p>截止到2017-09-26 16:17:35 influxdb已经更新到V1.3.5,但是新的版本改动很大把<code>Web Admin Interface</code>取消了。都融合到了<code>Chronograf</code>,功能似乎是增强了，但是，，<code>Chronograf</code>需要独立安装，而且，，<code>Chronograf</code>安装时似乎还要依赖<code>Kapacitor</code>,<code>Telegraf</code>，我不知道这是不是捆绑经营，所以我选择装之前版本，本来还想拥抱最新版的，看起来现在不是时候。</p>
</blockquote>
<p><strong>V1.2.0安装过程</strong></p>
<pre><code>wget http://dl.influxdata.com/influxdb/releases/influxdb-1.2.0.x86_64.rpm
yum install influxdb-1.2.0.x86_64.rpm
service influxdb start</code></pre><p>修改 /etc/influxdb/influxdb.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin]</span><br><span class="line"> 		# Determines whether the admin service is enabled.</span><br><span class="line">  		enabled &#x3D; true</span><br><span class="line"></span><br><span class="line"> 		# The default bind address used by the admin service.</span><br><span class="line">  		bind-address &#x3D; &quot;:8083&quot;</span><br></pre></td></tr></table></figure>

<p>influx 用户<code>root</code> 默认密码 <code>root</code><br>修改密码</p>
<p>  SET PASSWORD FOR root = ‘root’</p>
<p>后面的初始化我们可以到<code>http://localhost:8083</code>完成。还可以借助旁边<code>Query Template</code></p>
<p>比如创建用户<br><img src="http://or2jd66dq.bkt.clouddn.com/influx_web.png" alt=""><br>    CREATE USER “root” WITH PASSWORD ‘123456’ WITH ALL PRIVILEGES</p>
<p>新建库<br>    CREATE DATABASE “db_name”</p>
<h1 id="grafana安装"><a href="#grafana安装" class="headerlink" title="grafana安装"></a>grafana安装</h1><blockquote>
<p>grafana必须最新版</p>
</blockquote>
<pre><code>wget https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.5.2-1.x86_64.rpm
yum install grafana-4.5.2-1.x86_64.rpm
service grafana start</code></pre><p>配置DataSource<br><img src="http://or2jd66dq.bkt.clouddn.com/kafka_grafana_peizhi.png" alt=""></p>
<p>记得把admin用户禁用或者改密码，依稀还记得之前公司请了个白帽子扫公司环境，就是因为grafana默认端口，admin用户还是用的默认密码，我们小米监控数据图都在grafana上，这令我一度十分尴尬。所以，禁用admin吧。。</p>
<h1 id="jmxtrans安装"><a href="#jmxtrans安装" class="headerlink" title="jmxtrans安装"></a>jmxtrans安装</h1><pre><code>wget http://central.maven.org/maven2/org/jmxtrans/jmxtrans/266/jmxtrans-266.rpm
yum install jmxtrans-266.rpm  
/etc/init.d/jmxtrans start </code></pre><p>下面我们需要在<code>/var/lib/jmxtrans/</code>文件下增加json格式的配置文件,因为jmxtrans每次都是从这个目录读取json文件的。<br>参考<a href="https://github.com/jmxtrans/jmxtrans/wiki/InfluxDBWriter">influxDBwriter</a></p>
<p>格式类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;servers&quot; : [ &#123;</span><br><span class="line">    &quot;port&quot; : &quot;1099&quot;,</span><br><span class="line">    &quot;host&quot; : &quot;w2&quot;,</span><br><span class="line">    &quot;queries&quot; : [ &#123;</span><br><span class="line">      &quot;obj&quot; : &quot;kafka.server:type&#x3D;BrokerTopicMetrics,name&#x3D;BytesInPerSec,topic&#x3D;*&quot;,</span><br><span class="line">      &quot;attr&quot; : [ &quot;HeapMemoryUsage&quot;, &quot;NonHeapMemoryUsage&quot; ],</span><br><span class="line">      &quot;resultAlias&quot;:&quot;jvmMemory&quot;,</span><br><span class="line">      &quot;outputWriters&quot; : [ &#123;</span><br><span class="line">        &quot;@class&quot; : &quot;com.googlecode.jmxtrans.model.output.InfluxDbWriterFactory&quot;,</span><br><span class="line">        &quot;url&quot; : &quot;http:&#x2F;&#x2F;127.0.0.1:8086&#x2F;&quot;,</span><br><span class="line">        &quot;username&quot; : &quot;admin&quot;,</span><br><span class="line">        &quot;password&quot; : &quot;admin&quot;,</span><br><span class="line">        &quot;database&quot; : &quot;jmxDB&quot;,</span><br><span class="line">        &quot;tags&quot;     : &#123;&quot;application&quot; : &quot;kafka&quot;&#125;</span><br><span class="line">      &#125; ]</span><br><span class="line">    &#125; ]</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其中重要项目做一下解读：</p>
<ul>
<li>obj - 对应jmx的ObjectName，监控指标后面加上<code>topic=*</code>之后可以按照每个topic收集，否则不会</li>
<li>resultAlias - This is used as the <code>measurement</code> container in the database(influxdb)相当于表名    </li>
<li>tags - 对应InfluxDb的tag功能，对与存储在同一个MEASUREMENTS里面的不同监控指标可以做区分，相当于带索引的字段</li>
</ul>
<p>关于kafka jmx metrics 请移步<a href="http://kafka.apache.org/documentation.html#monitoring">官网传送门</a></p>
<p>metrics采集参考<br><a href="https://blog.serverdensity.com/how-to-monitor-kafka/">https://blog.serverdensity.com/how-to-monitor-kafka/</a></p>
<p>问题处理参考<br><a href="https://www.cloudera.com/documentation/kafka/latest/topics/kafka_metrics.html">https://www.cloudera.com/documentation/kafka/latest/topics/kafka_metrics.html</a></p>
<h2 id="metric"><a href="#metric" class="headerlink" title="metric"></a>metric</h2><h3 id="集群状态相关"><a href="#集群状态相关" class="headerlink" title="集群状态相关"></a>集群状态相关</h3><ul>
<li>kafka.server:type=ReplicaFetcherManager,name=MaxLag,clientId=Replica,topic=*    副本最大延时(message个数) </li>
<li>kafka.server:type=ReplicaManager,name=UnderReplicatedPartitions                 不可用分区数 </li>
<li>kafka.controller:type=KafkaController,name=ActiveControllerCount                leader of broker </li>
<li>kafka.network: type=SocketServer, name=RequestHandlerAvgIdlePercent             请求平均处理率 </li>
<li>kafka.server:type=ReplicaManager,name=PartitionCount                            partition数量 </li>
<li>java.lang:type=Threading                                                        java线程数 </li>
<li>java.lang:type=GarbageCollector,name=*                                          javaGC频率 </li>
<li>java.lang:type=Memory                                                           Java内存使用情况 </li>
</ul>
<h3 id="网络流量相关"><a href="#网络流量相关" class="headerlink" title="网络流量相关"></a>网络流量相关</h3><ul>
<li>kafka.network:type=RequestMetrics,name=RequestsPerSec,request=* </li>
<li>kafka.network:type=RequestMetrics,name=TotalTimeMs,request=* </li>
<li>kafka.server:type=BrokerTopicMetrics,name=BytesInPerSec,topic=*       流入流量 </li>
<li>kafka.server:type=BrokerTopicMetrics,name=BytesOutPerSec,topic=*      流出流量 </li>
<li>kafka.server:type=BrokerTopicMetrics,name=BytesRejectedPerSec,topic=* 拒绝流量 </li>
<li>kafka.server:type=BrokerTopicMetrics,name=MessagesInPerSec,topic=*    流入消息量 </li>
</ul>
<p>最终效果图<br>可以加一些template变量，更方便查看<br><img src="http://or2jd66dq.bkt.clouddn.com/kafka_flow_grafana_1.png" alt=""><br><img src="http://or2jd66dq.bkt.clouddn.com/kafka_flow_grafana_2.png" alt=""><br><img src="http://or2jd66dq.bkt.clouddn.com/kafka_flow_grafana_3.png" alt=""><br>也可以自己制作一些报表<br><img src="http://or2jd66dq.bkt.clouddn.com/kafka_flow_baobiao.png" alt=""></p>
<h1 id="问题发现及处理"><a href="#问题发现及处理" class="headerlink" title="问题发现及处理"></a>问题发现及处理</h1><h2 id="grafana绘图不完全的问题"><a href="#grafana绘图不完全的问题" class="headerlink" title="grafana绘图不完全的问题"></a>grafana绘图不完全的问题</h2><p><strong>问题描述：</strong></p>
<p>当我绘制每个集群中所有Topic的流量图的时候，到一个比较大的集群的时候，会出现某个Topic显示不全这种情况。比如说集群中有300个Topic，当你group by的时候，只会显示几十个，但是当你在自己设置的变量中去特意选没有出现的Topic的时候，该Topic曲线也能被绘制出来。</p>
<p><strong>问题分析：</strong></p>
<p>我一度以为并深信这是grafana的问题，并试图去给grafana增加系统资源，到处搜索”grafana graph query limit”然而并没有什么结果，终于，几天之后当我展示最近30分钟的数据的时候，所有的Topic都被展示出来了，我才意识到这锅并不是grafana的，应该是influx的。然后去看了一下influxdb的配置文档，终于有所发现..</p>
<p>在<code>influxdb.conf</code>中的[http]模块有个默认的配置<br>  max-row-limit = 10000<br>这条配置的意思是每次查询，最大返回一万条数据，我们每分钟一个点，一天的数据，几百个Topic，很容易就达到了也就是说七个Topic就回达到这个阈值，所以要把这个值改的大一点。如果改的特别大之后别忘了给influxdb增加一些系统资源，省的出问题。</p>
<p>参考<br><a href="http://navyaijm.blog.51cto.com/4647068/1958376">http://navyaijm.blog.51cto.com/4647068/1958376</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/09/12/kafka%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/09/12/kafka%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">kafka常用操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-12 19:10:27" itemprop="dateCreated datePublished" datetime="2017-09-12T19:10:27+08:00">2017-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:03" itemprop="dateModified" datetime="2020-05-21T20:56:03+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="fanquqi.github.io/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="topic-相关"><a href="#topic-相关" class="headerlink" title="topic 相关"></a>topic 相关</h1><h2 id="新建topic"><a href="#新建topic" class="headerlink" title="新建topic"></a>新建topic</h2><pre><code>bin/kafka-topics.sh --zookeeper node01:2181 --create --topic t_test --partitions 30  --replication-factor 2</code></pre><ul>
<li>–zookeeper 指定zk地址 </li>
<li>–topic 后面”t_test”为定义的topic name</li>
<li>–partition 指定分区数</li>
<li>–relication-factor 副本数 </li>
</ul>
<h2 id="查看所有topic"><a href="#查看所有topic" class="headerlink" title="查看所有topic"></a>查看所有topic</h2><pre><code>bin/kafka-topics.sh --zookeeper node01:2181 --list</code></pre><h2 id="查看指定topic信息"><a href="#查看指定topic信息" class="headerlink" title="查看指定topic信息"></a>查看指定topic信息</h2><pre><code>bin/kafka-topics.sh --zookeeper localhost:2181 --descirbe --topic topic_name</code></pre><h2 id="手动产生消息"><a href="#手动产生消息" class="headerlink" title="手动产生消息"></a>手动产生消息</h2><pre><code>需要交互输入
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test 
Hello Kafka！
nihao shijie</code></pre><h2 id="手动消费消息"><a href="#手动消费消息" class="headerlink" title="手动消费消息"></a>手动消费消息</h2><pre><code>bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</code></pre><h2 id="查看未被消费的消息数（topic-消息总数）"><a href="#查看未被消费的消息数（topic-消息总数）" class="headerlink" title="查看未被消费的消息数（topic 消息总数）"></a>查看未被消费的消息数（topic 消息总数）</h2><pre><code>bin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker  –zookeeper localhost:2181  –group logstash</code></pre><h1 id="副本相关"><a href="#副本相关" class="headerlink" title="副本相关"></a>副本相关</h1><blockquote>
<p>这里介绍下kafka 副本复制的过程，很巧妙。Kafka每个主题分区有N个副本,其中n是主题的复制因子。Kafka通过多副本机制实现自动故障转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的预写式日志有序地写到其他节点上。N个replicas中。一个replica为leader，其他都为follower，leader处理对这个partition的所有读写请求，与此同时，follower会被动地去复制leader上的数据。 </p>
</blockquote>
<p>复制过程参考()[]</p>
<h2 id="增加topic副本数量"><a href="#增加topic副本数量" class="headerlink" title="增加topic副本数量"></a>增加topic副本数量</h2><ul>
<li>首先查看topic信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --describe --topic test_byhands</span><br><span class="line"></span><br><span class="line">	Topic:test_byhands	PartitionCount:3	ReplicationFactor:2	Configs:</span><br><span class="line">		Topic: test_byhands	Partition: 0	Leader: 1	Replicas: 1,3	Isr: 1,3</span><br><span class="line">		Topic: test_byhands	Partition: 1	Leader: 3	Replicas: 3,2	Isr: 3,2</span><br><span class="line">		Topic: test_byhands	Partition: 2	Leader: 1	Replicas: 1,3	Isr: 1,3</span><br></pre></td></tr></table></figure>

<pre><code>可以看到这个topic信息有3个partition 两个副本</code></pre><ul>
<li>手工构造一个json文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   	&quot;version&quot;: 1, </span><br><span class="line">   	&quot;partitions&quot;: [</span><br><span class="line">       	&#123;</span><br><span class="line">           	&quot;topic&quot;: &quot;test_byhands&quot;, </span><br><span class="line">           	&quot;partition&quot;: 0, </span><br><span class="line">           	&quot;replicas&quot;: [</span><br><span class="line">               	1, </span><br><span class="line">               	3,</span><br><span class="line">               	2</span><br><span class="line">           	]</span><br><span class="line">       	&#125;,</span><br><span class="line">       	&#123;</span><br><span class="line">           	&quot;topic&quot;: &quot;test_byhands&quot;, </span><br><span class="line">           	&quot;partition&quot;: 1, </span><br><span class="line">           	&quot;replicas&quot;: [</span><br><span class="line">               	3, </span><br><span class="line">               	2, </span><br><span class="line">               	1</span><br><span class="line">           	]</span><br><span class="line">       	&#125;,</span><br><span class="line">       	&#123;</span><br><span class="line">           	&quot;topic&quot;: &quot;test_byhands&quot;,</span><br><span class="line">           	&quot;partition&quot;: 2,</span><br><span class="line">           	&quot;replicas&quot;: [</span><br><span class="line">               	1,</span><br><span class="line">               	3,</span><br><span class="line">               	2</span><br><span class="line">           	]</span><br><span class="line">       	&#125;</span><br><span class="line">   	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file add_replicas.json --execute</span><br><span class="line"></span><br><span class="line">Current partition replica assignment</span><br><span class="line"></span><br><span class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;test_byhands&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3,2]&#125;,&#123;&quot;topic&quot;:&quot;test_byhands&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,3]&#125;,&#123;&quot;topic&quot;:&quot;test_byhands&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,3]&#125;]&#125;</span><br><span class="line"></span><br><span class="line">Save this to use as the --reassignment-json-file option during rollback</span><br><span class="line">Successfully started reassignment of partitions &#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;test_byhands&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,3,2]&#125;,&#123;&quot;topic&quot;:&quot;test_byhands&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3,2,1]&#125;,&#123;&quot;topic&quot;:&quot;test_byhands&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,3,2]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查确认</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --describe --topic test_byhands</span><br><span class="line"></span><br><span class="line">Topic:test_byhands	PartitionCount:3	ReplicationFactor:3	Configs:</span><br><span class="line">	Topic: test_byhands	Partition: 0	Leader: 1	Replicas: 1,3,2	Isr: 1,3,2</span><br><span class="line">	Topic: test_byhands	Partition: 1	Leader: 3	Replicas: 3,2,1	Isr: 3,2,1</span><br><span class="line">	Topic: test_byhands	Partition: 2	Leader: 1	Replicas: 1,3,2	Isr: 1,3,2</span><br></pre></td></tr></table></figure>

<p>副本添加完成。。</p>
<h2 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h2><blockquote>
<p>在kafka老的版本里面好像是不支持直接删除topic的，但是0.9之后的都可以。。</p>
</blockquote>
<h2 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h2><blockquote>
<p>当集群压力增大，或者磁盘不够用了之后，集群就需要扩容。一般是先加broker，然后更改之前partition数，然后rebanlance</p>
</blockquote>
<ul>
<li>正常安装broker</li>
</ul>
<p>平时</p>
<h1 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h1><p>num.replica.fetchers 默认1 副本同步线程</p>
<p>以下两个参数调整messages 大小<br>message.max.bytes=10485760<br>replica.fetch.max.bytes=10485760</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanquqi.github.io/2017/09/12/zookeeper%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="fanquqi.github.io/images/avatar.gif">
      <meta itemprop="name" content="fanquqi">
      <meta itemprop="description" content="Raise my flag to the new age.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fix u dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="fanquqi.github.io/2017/09/12/zookeeper%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">zookeeper使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-12 19:10:27" itemprop="dateCreated datePublished" datetime="2017-09-12T19:10:27+08:00">2017-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 20:56:04" itemprop="dateModified" datetime="2020-05-21T20:56:04+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="fanquqi.github.io/categories/zookeeper/" itemprop="url" rel="index"><span itemprop="name">zookeeper</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作为一个国内的工程师，很多事情都是结果导向的，（这个好像跟国内国外没有关系，跟我们个人T级关系更大一点）比如说很多工作的时候，对于交到你手上的任务，很多做事认真的朋友先想到的是，我看官方文档仔细研究，全都吃透，然后再一点一点从头开始做，这样坑会比较少，对自己的提高也会更快。但是。。<br>真实的环境往往不是这样的，更多是需求方很着急，你的时间周期很短，时间紧，任务重。这个时候要怎样才合适？？<br>这个时候先上线，问题等到上线之后再处理，一点点发现，等到你能凭借经验规避一大部分问题那说明你已经很有经验了。因为老板想的更多是盈利，有可能你的级别不够直接跟老板汇报，那你就站在你领导或者项目负责人的角度想一下，他们肯定是想项目快点上线，任务快点完成，所以速度还是比较重要的，而这种情形下的我们应该更多的考虑在保证最快速度的情况下，尽量少发生或者不发生错误。so，先上线。。</p>
</blockquote>
<p>以上为刚换公司的我的一些工作感悟。。下边是正文。</p>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><blockquote>
<p>一言概之就是分布式一致性存储中间件。</p>
</blockquote>
<ul>
<li>ZAB （zookeeper atomic broadcast）zookeeer原子消息广播协议</li>
<li>zxid 事务id(自增) 要求顺序被执行（zab协议保证）</li>
<li>epoch leader的标记 自增</li>
<li>myid 整数值 集群初始化指定，每个节点不重复</li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>leader</li>
<li>flower</li>
<li>observer</li>
</ul>
<h1 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h1><h2 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h2><ul>
<li>少数服从多数 </li>
<li>每个server 推荐zxid最大的</li>
<li>如果zxid 一致，则按照myid 大 </li>
</ul>
<h2 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h2><p>假设leader down 掉。</p>
<ol>
<li>各个server除了observer其他状态置为LOOKING，然后开始投票</li>
<li>每个server发出投票广播 内容包含myid 与zxid</li>
<li>接收来自各个server的投票</li>
<li>按照选举规则，处理投票</li>
<li>改变服务器状态</li>
</ol>
<h1 id="基本cli命令"><a href="#基本cli命令" class="headerlink" title="基本cli命令"></a>基本cli命令</h1><p>zkCli.sh –server 127.0.0.1:2181</p>
<pre><code>ls(查看当前节点数据),
ls2(查看当前节点数据并能看到更新次数等数据),
create(创建一个节点),
get(得到一个节点，包含数据和更新次数等数据),
set(修改节点)
delete(删除一个节点)</code></pre><h1 id="基本四字命令"><a href="#基本四字命令" class="headerlink" title="基本四字命令"></a>基本四字命令</h1><blockquote>
<p>以下命令依靠<code>nc</code>命令。请安装</p>
</blockquote>
<pre><code>查看状态(包括zk版本，角色leader或者flower等)
echo stat | nc 127.0.0.1 2181

基本命令(Are you ok?)正常会回复imok(i am ok)
echo ruok | nc 127.0.0.1 2181

echo dump | nc 127.0.0.1 2181
列出未经处理的会话和临时节点。

终止进程
echo kill | nc 127.0.0.1 2181</code></pre><h2 id="利用四字命令查看某个ip-watch了哪些节点-如果节点较多-或者连接较多-慎用，会对cpu造成压力"><a href="#利用四字命令查看某个ip-watch了哪些节点-如果节点较多-或者连接较多-慎用，会对cpu造成压力" class="headerlink" title="利用四字命令查看某个ip watch了哪些节点(如果节点较多 或者连接较多 慎用，会对cpu造成压力)"></a>利用四字命令查看某个ip watch了哪些节点(如果节点较多 或者连接较多 慎用，会对cpu造成压力)</h2><ul>
<li><p>查看连接具体信息（可以拿到IP的session）</p>
<p>  echo cons | nc 127.0.0.1 2181</p>
</li>
<li></li>
</ul>
<h1 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h1><blockquote>
<p>以三节点扩容到五节点为例。听老司机们说zookeeper坑还是比较多的，大家操作小心，不要翻车。。</p>
</blockquote>
<ul>
<li><p><strong>首先部署新节点，在配置文件<code>zoo.cfg</code>中把新集群的地址都写进去</strong></p>
<p>  部署过程省略。说下配置文件改动部分</p>
<p>  三节点状态配置：<br>  server.1=10.0.0.2:2555:3555<br>  server.2=10.0.0.3:2555:3555<br>  server.3=10.0.0.4:2555:3555</p>
<p>  五节点状态配置：<br>  server.1=10.0.0.2:2555:3555<br>  server.2=10.0.0.3:2555:3555<br>  server.3=10.0.0.4:2555:3555<br>  server.2=10.0.0.5:2555:3555<br>  server.3=10.0.0.6:2555:3555</p>
</li>
</ul>
<p>然后    启动两个新节点。</p>
<p>原集群的三台机器，依次重启，按照myid从小到大（一定），leader最后重启。<br>以下是听老司机说的，并没有碰到，因为我直接按照myid从小到大重启的。。</p>
<blockquote>
<p><strong>我们重启服务的时候最好是依从myid从小到大依次重启, 因为这个里面又涉及到zookeeper另外一个设计.zookeeper是需要集群中所有集群两两建立连接, 其中配置中的3555端口是用来进行选举时机器直接建立通讯的端口, 为了避免重复创建tcp连接,如果对方myid比自己大，则关闭连接，这样导致的结果就是大id的server才会去连接小id的server，避免连接浪费.如果是最后重启myid最小的实例,该实例将不能加入到集群中,因为不能和其他集群建立连接, 这时你使用nc命令, 会有如下的提示: This ZooKeeper instance is not currently serving requests. 在zookeeper的启动日志里面你会发现这样的日志: Have smaller server identifier, so dropping the connection. 如果真的出现了这个问题, 也没关系, 但是需要先将报出该问题的实例起着,然后按照myid从小到大依次重启zk实例即可</strong></p>
</blockquote>
<p>重启完成之后。扩容完成。。</p>
<h1 id="配置说明及优化"><a href="#配置说明及优化" class="headerlink" title="配置说明及优化"></a>配置说明及优化</h1><p><strong>forceSync</strong></p>
<p>决定了写进去的数据是否应该sync到磁盘(zookeeper.forceSync)，yes或者no。<br>默认值为yes，在数据被sync到磁盘之前，事务对应的ack不会被发送回leader。sync系统调用很昂贵，且是事务处理中耗时最大的步骤。如果设置为no，那么数据一旦写到操作系统时，事务的ack马上会被发送，通常在数据真正落到磁盘前操作系统会把数据缓存起来。设置为no会提高性能，但是当server崩溃或者机器断电发生后，重启时的恢复的代价会变得更大</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><blockquote>
<p>针对日常使用过程中遇到的一些问题，和处理方法做一些记录。</p>
</blockquote>
<ol>
<li>ERROR CancelledKeyException</li>
</ol>
<p><strong>现象：</strong><br>zookeeper日志中报以下内容。</p>
<p><img src="/media/15232554895375.jpg" alt=""></p>
<p><strong>原因：</strong><br>su<br>zk 3.3.6之前的bug，并不会造成什么问题。<br>参考：<a href="https://stackoverflow.com/questions/36878333/why-do-i-get-a-cancelledkeyexception">https://stackoverflow.com/questions/36878333/why-do-i-get-a-cancelledkeyexception</a></p>
<ol start="2">
<li>磁盘io满</li>
</ol>
<blockquote>
<p>kafka 集群收到报警。只有 sda磁盘io报警。其他的数据盘都没有问题。(我们使用的多块独立数据盘)问题很蹊跷，</p>
</blockquote>
<p>处理过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. iotop 查看发现并不是kafka进程占用的io资源。发现 **kjournald** 才是元凶。 </span><br><span class="line">2. 发现系统日志都很小，没有问题，但是同时发现报警机器都是zk节点</span><br><span class="line">3. 排查zk日志，发现zk连接多 ，有业务使用stream消费kafka offset提交到zk 很频繁</span><br><span class="line">4. 更改启动参数&quot;-Dzookeeper.snapCount&#x3D;200000&quot; &quot;-Dzookeeper.forceSync&#x3D;no&quot; 重启 问题解决。</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>zk保障了强一致，为了做到安全系数非常高，<br>默认<code>forceSync</code> 参数为<code>yes</code> 也就是说 只有有一次事物操作。就会强制刷一次盘，好厉害。。这样对性能损耗是非常大的，但是我们也不是鼓励频繁操作zk。在安全范围内 ，这个吞吐限制还是有点大。<br><code>snapCount</code> 默认参数是 100000 ，它用于配置相邻两次快照之间的事物操作次数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="fanquqi.github.io/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="fanquqi.github.io/">1</a><a class="page-number" href="fanquqi.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="fanquqi.github.io/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="fanquqi.github.io/page/8/">8</a><a class="extend next" rel="next" href="fanquqi.github.io/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">fanquqi</p>
  <div class="site-description" itemprop="description">Raise my flag to the new age.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="fanquqi.github.io/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fanquqi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="fanquqi.github.io/lib/anime.min.js"></script>
  <script src="fanquqi.github.io/lib/velocity/velocity.min.js"></script>
  <script src="fanquqi.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="fanquqi.github.io/js/utils.js"></script>

<script src="fanquqi.github.io/js/motion.js"></script>


<script src="fanquqi.github.io/js/schemes/muse.js"></script>


<script src="fanquqi.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
